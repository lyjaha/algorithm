package com.ly.leetcode.hot100.array;

/**
 *  53. 最大子数组和
 *
 *  给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
 *  子数组 是数组中的一个连续部分。
 *
 *  进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
 *
 *  输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
 *  输出：6
 *  解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
 *
 *  输入：nums = [1]
 *  输出：1
 *
 *  输入：nums = [5,4,-1,7,8]
 *  输出：23
 *
 */
public class MaxSubArray {

    /**
     * 方法1：动态规划
     *
     * 知识点：动态规划
     *
     * 思路：
     * 1. 可以使用动态规划的方法来解决这个问题。关键是定义好状态和状态转移方程。
     * 2. 定义一个变量`maxSum`来存储当前的最大和，初始值为数组第一个元素`nums[0]`。
     * 3. 遍历数组nums，从第二个元素开始，计算以当前元素为结尾的最大和连续子数组的和并更新`maxSum`：
     *    - 为了保持连续性，如果前面的元素的和大于0，则将其加入当前元素；否则，舍弃前面的元素，以当前元素为起点
     *      重新计算连续子数组的和。
     *    - 在每次遍历的过程中，记下最大的`maxSum`。
     * 4. 遍历结束后，返回`maxSum`。
     *
     * 转移方程：pre = max(pre + x, x)
     *
     *
     * 步骤：
     * 1. 初始化变量`maxSum`为数组第一个元素`nums[0]`。
     * 2. 遍历数组nums，从第二个元素开始，执行以下步骤：
     *    - 如果前面的元素的和大于0，则将其累加到当前元素上；否则，舍弃前面的元素，以当前元素为新的起点。
     *    - 在每次遍历的过程中，比较并更新`maxSum`。
     * 3. 返回`maxSum`。
     *
     * 时空复杂度：
     * - 时间复杂度：O(n)，其中n是数组nums的长度。我们只需遍历一次数组nums即可找出最大和的连续子数组。
     * - 空间复杂度：O(1)，因为我们只使用了有限的额外变量。
     *
     * @param nums
     * @return
     */
    public static int maxSubArray(int[] nums) {

        int pre = 0, maxAns = nums[0];

        for (int x : nums) {
            // 转移方程：pre = max(pre + x, x)
            pre = Math.max(pre + x, x);
            // 更新最大和：maxAns = max(maxAns, pre)
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;

    }


    /**
     * 当我们根据转移方程 `pre = max(pre + x, x)` 和 `maxAns = max(maxAns, pre)` 遍历数组 `nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4}` 时，我们可以演示一下 `pre` 和 `maxAns` 的变化过程：
     *
     * 初始时，`pre` 和 `maxAns` 都等于数组的第一个元素 `-2`。
     *
     * 1. 遍历到第二个元素 `1` 时：
     *    - `pre = max(-2 + 1, 1) = 1`，即以元素 `1` 结尾的最大和连续子数组的和为 `1`。
     *    - `maxAns` 不变，仍为 `-2`。
     *
     * 2. 遍历到第三个元素 `-3` 时：
     *    - `pre = max(1 + (-3), -3) = -2`，即以元素 `-3` 结尾的最大和连续子数组的和为 `-2`。
     *    - `maxAns` 更新为 `max(-2, 1) = 1`，即此时的最大和为 `1`。
     *
     * 3. 遍历到第四个元素 `4` 时：
     *    - `pre = max(-2 + 4, 4) = 4`，即以元素 `4` 结尾的最大和连续子数组的和为 `4`。
     *    - `maxAns` 更新为 `max(4, 1) = 4`，即此时的最大和为 `4`。
     *
     * 4. 遍历到第五个元素 `-1` 时：
     *    - `pre = max(4 + (-1), -1) = 3`，即以元素 `-1` 结尾的最大和连续子数组的和为 `3`。
     *    - `maxAns` 更新为 `max(4, 4) = 4`，无变化。
     *
     * 5. 以此类推，最终得到 `maxAns` 为 `6`，即数组中具有最大和的连续子数组 `[4, -1, 2, 1]` 的和。
     *
     * 在遍历的过程中，`pre` 用来记录以当前元素为结尾的最大和连续子数组的和，而 `maxAns` 用来记录全局的最大和。通过比较和更新 `pre` 和 `maxAns` 的值，我们可以得到最大和的连续子数组。
     *
     * 希望这个示例能更好地展示 `pre` 和 `maxAns` 在遍历过程中的变化。
     *
     *
     * @param args
     */
    public static void main(String[] args) {
        int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        int maxSum = maxSubArray(nums);
        System.out.println("最大和的连续子数组的和为：" + maxSum);
    }
}
