package com.ly.nk.dynamicArrays;

/**
 *  BM72 连续子数组的最大和
 *
 *  描述：
 *  输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为1。求所有子数组的和的最大值。
 *  数据范围:
 *  1< = n <= 2×10的5次方
 *  −100 <= a[i] <= 100
 *
 *  要求:时间复杂度为 O(n)，空间复杂度为 O(n)
 *  进阶:时间复杂度为 O(n)，空间复杂度为 O(1)
 *
 *  输入：[1,-2,3,10,-4,7,2,-5]
 *  输出：18
 *  说明：经分析可知，输入数组的子数组[3,10,-4,7,2]可以求得最大和为18
 *
 *  输入：[2]
 *  输出：2
 *
 *  输入：[-10]
 *  输出：-10
 */
public class FindLargestSubarray {

    /**
     * 方法1：动态规划
     *
     * 知识点：动态规划
     * 动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；
     * 对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。
     * 动态规划算法将问题的解决方案视为一系列决策的结果。
     *
     * 思路：
     * 因为数组中有正有负有0，因此每次遇到一个数，要不要将其加入我们所求的连续子数组里面，是个问题，有可能加入了会更大，
     * 有可能加入了会更小，而且我们要求连续的最大值，因此这类有状态转移的问题可以考虑动态规划。
     *
     * 步骤：
     *  1：可以用dp数组表示以下标i为终点的最大连续子数组和。
     *  2：遍历数组，每次遇到一个新的数组元素，连续的子数组要么加上变得更大，要么这个元素本身就更大，要么会更小，更小我们就舍弃，
     *  因此状态转移为 dp[i] = max(dp[i−1]+array[i],array[i])。
     *  3：因为连续数组可能会断掉，每一段只能得到该段最大值，因此我们需要维护一个最大值。
     *
     * 时空复杂度：
     * 时间复杂度：O(n)，其中n为数组长度，遍历一次数组
     * 空间复杂度：O(n)，动态规划辅助数组长度为n
     *
     * @param array int整型一维数组
     * @return int整型
     */
    public int findGreatestSumOfSubArray (int[] array) {
        // 动态规划数组，记录到当前位置的最大子数组和
        int[] dp = new int[array.length];
        // 初始化dp数组的第一个元素
        dp[0] = array[0];
        // 记录最大的子数组和
        int maxSum = dp[0];
        for (int i = 1; i < array.length; i++) {
            //状态转移：计算dp[i]，取两者中的较大值
            dp[i] = Math.max(dp[i - 1] + array[i], array[i]);
            // 更新最大的子数组和
            maxSum = Math.max(maxSum, dp[i]);

        }
        return maxSum;
    }


    /**
     * 方法2：动态规划空间优化
     *
     * 知识点：动态规划
     * 动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；
     * 对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。
     * 动态规划算法将问题的解决方案视为一系列决策的结果。
     *
     * 思路：
     * 我们注意到方法一的动态规划在状态转移的时候只用到了i−1的信息，没有使用整个辅助数组的信息，因此可以将数组优化掉。
     *
     * 步骤：
     *  1：我们可以使用两个变量迭代来代替数组。
     *  2：状态转移的时候更新变量y，该轮循环结束的再更新x为y即可做到每次迭代都是上一轮的dp。
     *  3：遍历数组，每次只要比较取最大值即可。
     *
     * 时空复杂度：
     * 时间复杂度：O(n)，其中n为数组长度，遍历一次数组
     * 空间复杂度：O(1)，常数级变量，无额外辅助空间
     *
     * @param array int整型一维数组
     * @return int整型
     */
    public int findGreatestSumOfSubArray2 (int[] array) {
        // 记录到当前位置的最大子数组和
        int curSum = array[0];
        // 记录最大的子数组和
        int maxSum = 0;
        for (int i = 1; i < array.length; i++) {
            //状态转移：连续子数组和最大值
            curSum = Math.max(curSum + array[i], array[i]);
            //维护最大值
            maxSum = Math.max(maxSum, curSum);
        }
        return maxSum;
    }

}
