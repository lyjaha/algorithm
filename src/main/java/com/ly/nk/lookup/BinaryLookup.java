package com.ly.nk.lookup;

/**
 *  BM17 二分查找-I
 *
 *  描述：
 *  请实现无重复数字的升序数组的二分查找
 *  给定一个 元素升序的、无重复数字的整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，
 *  如果目标值存在返回下标（下标从 0 开始），否则返回 -1
 *
 *  数据范围：0 ≤len(nums)≤ 2×10的5次方， 数组中任意值满足∣val∣≤10的9次方
 *
 *  进阶：时间复杂度 O(logn) ，空间复杂度 O(1)
 *
 * 示例
 * 输入：[-1,0,3,4,6,10,13,14],13
 * 返回值：6
 * 说明：13 出现在nums中并且下标为 6
 *
 */
public class BinaryLookup {

    /**
     *  方法1：二分法
     *
     *  知识点：分治
     *  分治即“分而治之”，“分”指的是将一个大而复杂的问题划分成多个性质相同但是规模更小的子问题，子问题继续按照这样划分，
     *  直到问题可以被轻易解决；“治”指的是将子问题单独进行处理。经过分治后的子问题，需要将解进行合并才能得到原问题的解，
     *  因此整个分治过程经常用递归来实现。
     *
     *  思路：
     *
     *  步骤：
     *  1：从数组首尾开始，每次取中点值。
     *  2：如果中间值等于目标即找到了，可返回下标，如果中点值大于目标，说明中点以后的都大于目标，因此目标在中点左半区间，
     *  如果中点值小于目标，则相反。
     *  3：根据比较进入对应的区间，直到区间左右端相遇，意味着没有找到。
     *
     *  时空复杂度：
     *  时间复杂度：O(log2n)，对长度为n的数组进行二分，最坏情况就是取2的对数
     *  空间复杂度：O(1)，常数级变量，无额外辅助空间
     *
     * @param nums
     * @param target
     * @return
     */
    public static int search (int[] nums, int target) {

        int l = 0;
        int r = nums.length - 1;
        //从数组首尾开始，直到二者相遇
        while (l <= r) {
            //每次检查中点的值
            int m = (l + r) / 2;
            if (nums[m] == target) {
                return m;
            }
            //进入左的区间
            if (nums[m] > target) {
                r = m - 1;
            }else {
                l = m + 1;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] nums = {1,2,3,4,5};
        search(nums,5);
    }
}
