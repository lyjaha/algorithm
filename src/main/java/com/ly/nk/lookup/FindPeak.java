package com.ly.nk.lookup;

/**
 *  BM19 寻找峰值
 *
 *  描述：
 *  给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。
 *  1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于
 *  2.假设 nums[-1] = nums[n] = −∞
 *  3.对于所有有效的 i 都有 nums[i] != nums[i + 1]
 *  4.你可以使用O(logN)的时间复杂度实现此问题吗？
 *
 * 示例
 * 输入：[2,4,1,2,7,8,4]
 * 返回值：1
 * 说明：4和8都是峰值元素，返回4的索引1或者8的索引5都可以
 *
 * 输入：[1,2,3,1]
 * 返回值：2
 */
public class FindPeak {

    /**
     *  方法1：二分查找
     *
     *  知识点：分治
     *
     *  思路：
     *  下坡的时候可能找到波峰，但是可能找不到，一直向下走的,上坡的时候一定能找到波峰，因为题目给出的是
     *  nums[-1] = nums[n] = -∞
     *
     *  步骤：
     *  1：二分查找首先从数组首尾开始，每次取中间值，直到首尾相遇。
     *  2：如果中间值的元素大于它右边的元素，说明往右是向下，我们不一定会遇到波峰，那就往左收缩区间。
     *  3：如果中间值大于右边的元素，说明此时往右是向上，向上一定能有波峰，那我们往右收缩区间。
     *  4：最后区间收尾相遇的点一定就是波峰。
     *
     *  时空复杂度：
     *  时间复杂度：O(log2n)，二分法最坏情况对整个数组连续二分，最多能分 log2n 次
     *  空间复杂度：O(1)，常数级变量，无额外辅助空间
     *
     * @param nums
     * @return
     */
    public int findPeakElement (int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        //
        while (left < right) {
            // int mid = left+(right-left)/2;
            int mid = (left + right) / 2;
            //右边是往下，不一定有坡峰
            if (nums[mid] > nums[mid + 1]) {
                right = mid;
            }else {
                left = mid + 1;
            }
        }
        return right;
    }
}
